var fs = require('fs');

var Discord = require('discord.js');
var winston = require('winston');
var ytdl = require('ytdl-core');
var auth = require('./auth.json');
var settings = require('./settings.json');

var logger = winston.createLogger({
	level: 'debug',
	format: winston.format.json(),
	transports: [
		new winston.transports.File({ filename: 'logs/error.log', level: 'error'}),
		new winston.transports.File({ filename: 'logs/combined.log'})
	]
});

if(!logger || typeof logger == undefined || logger == null) {
	console.error('Failed to create logger');
	process.exit();
}

if(process.env.NODE_ENV !== 'production') {
	logger.add(new winston.transports.Console({
		colorize: true,
		format: winston.format.simple()
	}));
}

logger.info(`Creating Discord client with token '${auth.token}'`);

var client = new Discord.Client();

if(!client || typeof client == undefined || client == null) {
	logger.error('Failed to create Discord client');
	process.exit();
}

if(client.connected == false) {
	logger.error('Failed to connect to Discord');
	process.exit();
}

client.on('ready', () => {
	logger.info('Connected');
	logger.info(`Logged in as ${client.user.username}`);
	return;
});

client.on('message', msg => {
	if(msg.content === '!do_voice') {
		doUserEnter(msg.member);
	}

	if(msg.content === '!leave_voice') {
		leaveVoiceChannel(msg.member);
	}
});

client.on('voiceStateUpdate', (oldState, newState) => {
	let oldMember = oldState.member;
	let newMember = newState.member;

	let name = newMember.displayName;

	if(name === client.user.username) {
		return;
	}

	let oldVC = oldState.channel;
	let newVC = newState.channel;

	if(newVC !== null && typeof newVC !== 'undefined') {
		// This event gets triggered when ther user does anything in a voice channel
		// so we want to make sure we only trigger this piece of code when they enter a channel
		if(oldVC === null || typeof oldVC === 'undefined' || newVC.id !== oldVC.id) {
			// Check if the user is actually in the channel
			let m = newVC.members.find(m => m.displayName === name);
			if(m !== null && typeof m !== 'undefined') {
				doUserEnter(m);
			}
		} else {
			logger.info(oldVC.name);
		}
	}
});

function doUserEnter(member) {
	const channel_name = member.voice.channel.name;
	const chan_setting = settings.channels[channel_name];
	const name = member.displayName;

	if(chan_setting === null || typeof chan_setting === 'undefined' ||
		chan_setting.enterUsers === null || typeof chan_setting.enterUsers === 'undefined' ||
		chan_setting.enterUsers[name] === null || typeof chan_setting.enterUsers[name] === 'undefined')
	{
		logger.info(`No UserEnteredNoise for ${name} in channel ${channel_name}`);
		return;
	}

	let enterSoundPath = chan_setting.enterUsers[name].enterSound;
	if(enterSoundPath === null || typeof enterSoundPath === 'undefined') {
		logger.error(`No path to enter sound for user ${name} in channel ${channel_name}`);
		return;
	}

	let type = chan_setting.enterUsers[name].type;
	if(type === null || typeof type === 'undefined') {
		logger.error(`No type defined for enterSound for user ${name} in voice channel ${channel_name}`);
		return;
	}

	let volume = !!settings.youtubeVolume ? settings.youtubeVolume : 0.25

	tryJoinUserVoiceChannel(member)
		.then(con => {
			logger.info(`Connected with ${member.displayName}`);

			// Have a delay before sending audio to makek sure the bot is fully connected first
			setTimeout(() => {
					playNoise(con, member.displayName, type, enterSoundPath, volume);
				}, settings.userEnteredSoundDelay)
		})
		.catch(error => logger.error('Failed to join voice channel: ' + error));
}

function tryJoinUserVoiceChannel(member) {
	const vc = member.voice.channel;
	const name = member.displayName;

	// Check if user is entering the voice channel
	if(vc !== null && typeof vc !== 'undefined') {
		let m = vc.members.find(m => m.displayName === name);
		if(m !== null && typeof m !== 'undefined') {
			// Return promise generated by .join()
			return vc.join();
		} else {
			return Promise.reject(new Error(`Couldn't find ${name} in ${vc.name}`));
		}
	}

	return Promise.reject(new Error(`Couldn't find ${name} in a voice channel`));
}

function leaveVoiceChannel(member) {
	const vc = member.voice.channel;
	const name = member.displayName;

	// Check if user is entering the voice channel
	if(vc !== null && typeof vc !== 'undefined') {
		let m = vc.members.find(m => m.displayName === name);
		if(m !== null && typeof m !== 'undefined') {
			vc.leave();
			logger.info(`Left voice channel of ${member.displayName}`);
		}
	}
}

function playNoise(con, name, type, soundPath, volume) {
	let evt = null;
	if(type.toLowerCase() === 'youtube') {
		const stream = ytdl(soundPath, {
			filter: 'audioonly'
		});
		evt = con.play(stream, {
			seek: 0,
			volume: volume
		});
	} else if(type.toLowerCase() === 'file') {
		evt = con.play(`./sounds/${soundPath}`);
	} else {
		logger.error(`Invalid type '${type}' noise`);
	}

	if(evt !== null && typeof evt !== 'undefined') {
		evt.on('speaking', isSpeaking => {
			if(isSpeaking == false) {
				con.channel.leave();
			}
		});
		evt.on('error', () => {
			con.channel.leave();
		});
	}
}

client.login(auth.token);