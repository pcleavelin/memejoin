var fs = require('fs');

var { Client, Events, GatewayIntentBits } = require('discord.js');
var { AudioPlayerStatus, joinVoiceChannel, createAudioPlayer, createAudioResource } = require("@discordjs/voice");
var winston = require('winston');
var ytdl = require('ytdl-core');
var auth = require('./auth.json');
var settings = require('./settings.json');

var logger = winston.createLogger({
	level: 'debug',
	format: winston.format.json(),
	transports: [
		new winston.transports.File({ filename: 'logs/error.log', level: 'error'}),
		new winston.transports.File({ filename: 'logs/combined.log'})
	]
});

if(!logger || typeof logger == undefined || logger == null) {
	console.error('Failed to create logger');
	process.exit();
}

if(process.env.NODE_ENV !== 'production') {
	logger.add(new winston.transports.Console({
		colorize: true,
		format: winston.format.simple()
	}));
}

logger.info(`Creating Discord client with token '${auth.token}'`);

var client = new Client({ intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
] });

if(!client || typeof client == undefined || client == null) {
	logger.error('Failed to create Discord client');
	process.exit();
}

if(client.connected == false) {
	logger.error('Failed to connect to Discord');
	process.exit();
}

client.once(Events.ClientReady, () => {
	logger.info('Connected');
	logger.info(`Logged in as ${client.user.username}`);
	return;
});

client.on(Events.MessageCreate, msg => {
    logger.info('Msg: ${msg}');
	if(msg.content === '!do_voice') {
		doUserEnter(msg.member);
	}

	if(msg.content === '!leave_voice') {
		leaveVoiceChannel(msg.member);
	}
});

client.on('voiceStateUpdate', (oldState, newState) => {
	let oldMember = oldState.member;
	let newMember = newState.member;

	let name = newMember.displayName;

	if(name === client.user.username) {
		return;
	}

	let oldVC = oldState.channel;
	let newVC = newState.channel;

	if(newVC !== null && typeof newVC !== 'undefined') {
		// This event gets triggered when ther user does anything in a voice channel
		// so we want to make sure we only trigger this piece of code when they enter a channel
		if(oldVC === null || typeof oldVC === 'undefined' || newVC.id !== oldVC.id) {
			// Check if the user is actually in the channel
			let m = newVC.members.find(m => m.displayName === name);
			if(m !== null && typeof m !== 'undefined') {
				doUserEnter(m);
			}
		} else {
			logger.info(oldVC.name);
		}
	}
});

function doUserEnter(member) {
	const channel_name = member.voice.channel.name;
	const chan_setting = settings.channels[channel_name];
	const name = member.displayName;

	if(chan_setting === null || typeof chan_setting === 'undefined' ||
		chan_setting.enterUsers === null || typeof chan_setting.enterUsers === 'undefined' ||
		chan_setting.enterUsers[name] === null || typeof chan_setting.enterUsers[name] === 'undefined')
	{
		logger.info(`No UserEnteredNoise for ${name} in channel ${channel_name}`);
		return;
	}

	let enterSoundPath = chan_setting.enterUsers[name].enterSound;
	if(enterSoundPath === null || typeof enterSoundPath === 'undefined') {
		logger.error(`No path to enter sound for user ${name} in channel ${channel_name}`);
		return;
	}

	let type = chan_setting.enterUsers[name].type;
	if(type === null || typeof type === 'undefined') {
		logger.error(`No type defined for enterSound for user ${name} in voice channel ${channel_name}`);
		return;
	}

	let volume = !!settings.youtubeVolume ? settings.youtubeVolume : 0.25

	const connection = tryJoinUserVoiceChannel(member);

    if (!!connection) {
        logger.info(`Connected with ${member.displayName}`);

        const player = createAudioPlayer();

        // Have a delay before sending audio to makek sure the bot is fully connected first
        setTimeout(() => {
            playNoise(connection, player, member.displayName, type, enterSoundPath, volume);
        }, settings.userEnteredSoundDelay)
    }
}

function tryJoinUserVoiceChannel(member) {
	const vc = member.voice.channel;
	const name = member.displayName;

    if (vc.isVoiceBased()) {
        // Check if user is entering the voice channel
        if(vc !== null && typeof vc !== 'undefined') {
            let m = vc.members.find(m => m.displayName === name);
            if(m !== null && typeof m !== 'undefined') {
                // Return promise generated by .join()
                return joinVoiceChannel({
                    channelId: vc.id,
                    guildId: vc.guild.id,
                    adapterCreator: vc.guild.voiceAdapterCreator,
                });
            } else {
                return new Error(`Couldn't find ${name} in ${vc.name}`);
            }
        }
    }

    return new Error(`Couldn't find ${name} in a voice channel`);
}

function leaveVoiceChannel(member) {
	const vc = member.voice.channel;
	const name = member.displayName;

	// Check if user is entering the voice channel
	if(vc !== null && typeof vc !== 'undefined') {
		let m = vc.members.find(m => m.displayName === name);
		if(m !== null && typeof m !== 'undefined') {
			vc.leave();
			logger.info(`Left voice channel of ${member.displayName}`);
		}
	}
}

function playNoise(con, player, name, type, soundPath, volume) {
	let evt = null;
	if(type.toLowerCase() === 'youtube') {
        const stream = createAudioResource(ytdl(soundPath, {
            filter: 'audioonly'
        }), { inlineVolume: true });
        stream.volume.setVolume(volume);
		player.play(stream, {
			seek: 0,
		});

        con.subscribe(player);
	} else if(type.toLowerCase() === 'file') {
        const resource = createAudioResource(`./sounds/${soundPath}`, { inlineVolume: true });
        resource.volume.setVolume(volume);

		player.play(resource);
        con.subscribe(player);
	} else {
		logger.error(`Invalid type '${type}' noise`);
	}

    player.on(AudioPlayerStatus.Idle, () => con.destroy());
    player.on('error', error => {
        logger.error(`Audio Player error: ${error}`);
        con.destroy()
    });

}

client.login(auth.token);
